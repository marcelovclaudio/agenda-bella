# SEC-002: Implementar Autenticação JWT

## Informações da Task

- **Task ID**: SEC-002
- **Dependências**: SEC-001 ✅ (concluída), CORE-001 (package database)
- **Tempo Estimado**: 6h (24 subtasks × 15min)
- **Status**: 0/24 subtasks concluídas (0%) ⏳
- **Responsável**: -
- **Data Início**: -
- **Data Conclusão**: -

## Descrição

Implementar sistema completo de autenticação JWT integrado com a foundation do package @agenda-bella/security. Incluir geração/validação de tokens, refresh mechanism, middleware Express, e integração com database abstraction para gerenciamento de usuários e sessões.

## Objetivos

- Implementar geração e validação segura de JWT tokens com refresh mechanism
- Criar middleware Express para autenticação automática em rotas protegidas
- Integrar com database abstraction para persistência de usuários e sessões
- Estabelecer base sólida para próximas implementações de autorização (SEC-003)

---

## Phase 1: JWT Core Implementation (1.5h)

**Progress**: 6/6 subtasks concluídas ⏳

### - [x] SUB-SEC-002-01: [15min] Implementar JWT Token Generation

**Arquivos a criar/modificar:**
- `packages/security/src/auth/jwt.ts`
- `packages/security/src/auth/types.ts` (expandir)

**Implementação:**
```typescript
// auth/jwt.ts
import jwt from 'jsonwebtoken';
import { generateSecureSecret } from '../utils/crypto';
import type { JwtPayload, JwtConfig, AuthTokens } from './types';
import { AuthenticationError } from '../types/errors.types';
import { securityLogger } from '../utils';

export class JwtManager {
  private config: Required<JwtConfig>;

  constructor(config: JwtConfig) {
    this.config = {
      secret: config.secret || generateSecureSecret(32),
      expiresIn: config.expiresIn || '15m',
      refreshExpiresIn: config.refreshExpiresIn || '7d',
      algorithm: config.algorithm || 'HS256',
    };
    
    if (this.config.secret.length < 32) {
      throw new AuthenticationError('JWT secret must be at least 32 characters');
    }
  }

  generateTokens(payload: Omit<JwtPayload, 'iat' | 'exp'>): AuthTokens {
    const now = Math.floor(Date.now() / 1000);
    const accessPayload: JwtPayload = {
      ...payload,
      iat: now,
      exp: now + this.parseExpiresIn(this.config.expiresIn),
    };

    const refreshPayload = {
      sub: payload.sub,
      type: 'refresh',
      iat: now,
      exp: now + this.parseExpiresIn(this.config.refreshExpiresIn),
    };

    const accessToken = jwt.sign(accessPayload, this.config.secret, {
      algorithm: this.config.algorithm,
    });

    const refreshToken = jwt.sign(refreshPayload, this.config.secret, {
      algorithm: this.config.algorithm,
    });

    securityLogger.info('JWT tokens generated', {
      userId: payload.sub,
      accessTokenExp: accessPayload.exp,
    });

    return {
      accessToken,
      refreshToken,
      expiresAt: new Date(accessPayload.exp * 1000),
      tokenType: 'Bearer',
    };
  }

  private parseExpiresIn(expiresIn: string): number {
    const match = expiresIn.match(/^(\d+)([smhd])$/);
    if (!match) throw new Error('Invalid expiresIn format');
    
    const value = parseInt(match[1]);
    const unit = match[2];
    
    const multipliers = { s: 1, m: 60, h: 3600, d: 86400 };
    return value * multipliers[unit as keyof typeof multipliers];
  }
}
```

**Critérios de Aceitação:**
- [x] JWT Manager class implementada com configuração segura
- [x] Geração de access e refresh tokens funcionando
- [x] Validação de secret key com mínimo 32 caracteres
- [x] Logging de eventos de geração de tokens

---

### - [x] SUB-SEC-002-02: [15min] Implementar JWT Token Validation

**Arquivos a modificar:**
- `packages/security/src/auth/jwt.ts` (continuar)

**Implementação:**
```typescript
// auth/jwt.ts (adicionar métodos)
export class JwtManager {
  // ... métodos anteriores

  verifyAccessToken(token: string): JwtPayload {
    try {
      const payload = jwt.verify(token, this.config.secret, {
        algorithms: [this.config.algorithm],
      }) as JwtPayload;

      if (typeof payload === 'string') {
        throw new AuthenticationError('Invalid token format');
      }

      return payload;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new AuthenticationError('Token expired', { 
          code: 'TOKEN_EXPIRED',
          expiredAt: error.expiredAt 
        });
      }
      
      if (error instanceof jwt.JsonWebTokenError) {
        throw new AuthenticationError('Invalid token', { 
          code: 'INVALID_TOKEN',
          reason: error.message 
        });
      }
      
      throw error;
    }
  }

  verifyRefreshToken(token: string): { sub: string; type: string } {
    try {
      const payload = jwt.verify(token, this.config.secret, {
        algorithms: [this.config.algorithm],
      }) as any;

      if (payload.type !== 'refresh') {
        throw new AuthenticationError('Invalid refresh token type');
      }

      return { sub: payload.sub, type: payload.type };
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new AuthenticationError('Refresh token expired', { 
          code: 'REFRESH_TOKEN_EXPIRED' 
        });
      }
      
      throw new AuthenticationError('Invalid refresh token', { 
        code: 'INVALID_REFRESH_TOKEN' 
      });
    }
  }

  refreshTokens(refreshToken: string, newPayload: Omit<JwtPayload, 'iat' | 'exp'>): AuthTokens {
    this.verifyRefreshToken(refreshToken);
    
    securityLogger.info('JWT tokens refreshed', {
      userId: newPayload.sub,
    });
    
    return this.generateTokens(newPayload);
  }
}
```

**Critérios de Aceitação:**
- [x] Validação de access tokens com error handling específico
- [x] Validação de refresh tokens com type checking
- [x] Refresh mechanism implementado e testado
- [x] Error logging adequado para falhas de validação

---

### - [x] SUB-SEC-002-03: [15min] Expandir Auth Types

**Arquivos a modificar:**
- `packages/security/src/auth/types.ts`

**Implementação:**
```typescript
// auth/types.ts (expandir tipos existentes)
export interface JwtPayload {
  sub: string;      // User ID
  iat: number;      // Issued at
  exp: number;      // Expires at
  aud?: string;     // Audience
  iss?: string;     // Issuer
  roles?: string[];
  permissions?: string[];
  sessionId?: string;
  deviceInfo?: {
    userAgent?: string;
    ipAddress?: string;
  };
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresAt: Date;
  tokenType: 'Bearer';
}

export interface JwtConfig {
  secret: string;
  expiresIn: string;
  refreshExpiresIn: string;
  algorithm: 'HS256' | 'RS256';
}

export interface AuthenticatedUser {
  id: string;
  email: string;
  roles: string[];
  permissions: string[];
  sessionId: string;
  lastLoginAt: Date;
}

export interface LoginCredentials {
  email: string;
  password: string;
  deviceInfo?: {
    userAgent?: string;
    ipAddress?: string;
  };
}

export interface LoginResult {
  user: AuthenticatedUser;
  tokens: AuthTokens;
  isFirstLogin: boolean;
}

export interface RefreshTokenRequest {
  refreshToken: string;
  deviceInfo?: {
    userAgent?: string;
    ipAddress?: string;
  };
}

export interface LogoutRequest {
  refreshToken?: string;
  logoutAllDevices?: boolean;
}

// Database abstraction interfaces
export interface IUserRepository {
  findByEmail(email: string): Promise<AuthenticatedUser | null>;
  findById(id: string): Promise<AuthenticatedUser | null>;
  updateLastLogin(id: string): Promise<void>;
  validatePassword(email: string, password: string): Promise<boolean>;
}

export interface ISessionRepository {
  createSession(userId: string, refreshToken: string, deviceInfo?: any): Promise<string>;
  findSession(sessionId: string): Promise<{ userId: string; refreshToken: string } | null>;
  revokeSession(sessionId: string): Promise<void>;
  revokeAllUserSessions(userId: string): Promise<void>;
  isTokenBlacklisted(token: string): Promise<boolean>;
  blacklistToken(token: string, expiresAt: Date): Promise<void>;
}
```

**Critérios de Aceitação:**
- [ ] Interfaces completas para autenticação implementadas
- [ ] Database abstraction interfaces definidas
- [ ] Tipos para device tracking e session management
- [ ] Types exportados corretamente

---

### - [x] SUB-SEC-002-04: [15min] Implementar Token Blacklist System

**Arquivos a criar:**
- `packages/security/src/auth/blacklist.ts`

**Implementação:**
```typescript
// auth/blacklist.ts
import { createChildLogger } from '../utils';
import type { ISessionRepository } from './types';

const logger = createChildLogger({ component: 'token-blacklist' });

export class TokenBlacklistManager {
  constructor(private sessionRepo: ISessionRepository) {}

  async blacklistToken(token: string, expiresAt: Date): Promise<void> {
    await this.sessionRepo.blacklistToken(token, expiresAt);
    
    logger.info('Token blacklisted', {
      tokenHash: this.hashToken(token),
      expiresAt: expiresAt.toISOString(),
    });
  }

  async isTokenBlacklisted(token: string): Promise<boolean> {
    return await this.sessionRepo.isTokenBlacklisted(token);
  }

  async blacklistRefreshToken(refreshToken: string): Promise<void> {
    // Refresh tokens typically have longer expiration
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // 7 days default
    
    await this.blacklistToken(refreshToken, expiresAt);
  }

  private hashToken(token: string): string {
    // Return first 8 chars for logging (non-sensitive identifier)
    return token.substring(0, 8) + '...';
  }
}

// In-memory fallback implementation for development
export class MemoryTokenBlacklist implements Pick<ISessionRepository, 'blacklistToken' | 'isTokenBlacklisted'> {
  private blacklistedTokens = new Map<string, Date>();

  async blacklistToken(token: string, expiresAt: Date): Promise<void> {
    this.blacklistedTokens.set(token, expiresAt);
    
    // Clean up expired tokens periodically
    this.cleanupExpiredTokens();
  }

  async isTokenBlacklisted(token: string): Promise<boolean> {
    const expiry = this.blacklistedTokens.get(token);
    if (!expiry) return false;
    
    if (expiry <= new Date()) {
      this.blacklistedTokens.delete(token);
      return false;
    }
    
    return true;
  }

  private cleanupExpiredTokens(): void {
    const now = new Date();
    for (const [token, expiry] of this.blacklistedTokens.entries()) {
      if (expiry <= now) {
        this.blacklistedTokens.delete(token);
      }
    }
  }
}
```

**Critérios de Aceitação:**
- [x] Token blacklist manager implementado
- [x] Integração com session repository
- [x] Fallback in-memory implementation para desenvolvimento
- [x] Cleanup automático de tokens expirados

---

### - [x] SUB-SEC-002-05: [15min] Implementar Auth Service Principal

**Arquivos a criar:**
- `packages/security/src/auth/service.ts`

**Implementação:**
```typescript
// auth/service.ts
import { JwtManager } from './jwt';
import { TokenBlacklistManager } from './blacklist';
import { generateSecureUUID } from '../utils/crypto';
import { AuthenticationError } from '../types/errors.types';
import { auditLog } from '../utils';
import type {
  JwtConfig,
  LoginCredentials,
  LoginResult,
  RefreshTokenRequest,
  LogoutRequest,
  IUserRepository,
  ISessionRepository,
  AuthenticatedUser,
} from './types';

export class AuthService {
  private jwtManager: JwtManager;
  private blacklistManager: TokenBlacklistManager;

  constructor(
    private config: JwtConfig,
    private userRepo: IUserRepository,
    private sessionRepo: ISessionRepository
  ) {
    this.jwtManager = new JwtManager(config);
    this.blacklistManager = new TokenBlacklistManager(sessionRepo);
  }

  async login(credentials: LoginCredentials): Promise<LoginResult> {
    const { email, password, deviceInfo } = credentials;

    // Validate credentials
    const user = await this.userRepo.findByEmail(email);
    if (!user) {
      auditLog('login_failed', { email, reason: 'user_not_found', deviceInfo });
      throw new AuthenticationError('Invalid credentials');
    }

    const isPasswordValid = await this.userRepo.validatePassword(email, password);
    if (!isPasswordValid) {
      auditLog('login_failed', { userId: user.id, reason: 'invalid_password', deviceInfo });
      throw new AuthenticationError('Invalid credentials');
    }

    // Generate session and tokens
    const sessionId = generateSecureUUID();
    const tokens = this.jwtManager.generateTokens({
      sub: user.id,
      roles: user.roles,
      permissions: user.permissions,
      sessionId,
      deviceInfo,
    });

    // Store session
    await this.sessionRepo.createSession(user.id, tokens.refreshToken, deviceInfo);
    await this.userRepo.updateLastLogin(user.id);

    auditLog('login_success', {
      userId: user.id,
      sessionId,
      deviceInfo,
      tokenExpiresAt: tokens.expiresAt,
    });

    return {
      user: { ...user, sessionId },
      tokens,
      isFirstLogin: !user.lastLoginAt,
    };
  }

  async refreshTokens(request: RefreshTokenRequest): Promise<LoginResult> {
    const { refreshToken, deviceInfo } = request;

    // Check if token is blacklisted
    if (await this.blacklistManager.isTokenBlacklisted(refreshToken)) {
      throw new AuthenticationError('Token has been revoked');
    }

    // Verify refresh token
    const { sub: userId } = this.jwtManager.verifyRefreshToken(refreshToken);

    // Get user data
    const user = await this.userRepo.findById(userId);
    if (!user) {
      throw new AuthenticationError('User not found');
    }

    // Generate new tokens
    const newTokens = this.jwtManager.refreshTokens(refreshToken, {
      sub: user.id,
      roles: user.roles,
      permissions: user.permissions,
      sessionId: user.sessionId,
      deviceInfo,
    });

    // Blacklist old refresh token
    await this.blacklistManager.blacklistRefreshToken(refreshToken);

    auditLog('token_refresh', {
      userId: user.id,
      deviceInfo,
      newTokenExpiresAt: newTokens.expiresAt,
    });

    return {
      user,
      tokens: newTokens,
      isFirstLogin: false,
    };
  }

  async logout(userId: string, request: LogoutRequest): Promise<void> {
    const { refreshToken, logoutAllDevices = false } = request;

    if (logoutAllDevices) {
      await this.sessionRepo.revokeAllUserSessions(userId);
    } else if (refreshToken) {
      await this.blacklistManager.blacklistRefreshToken(refreshToken);
    }

    auditLog('logout', {
      userId,
      logoutAllDevices,
      hasRefreshToken: !!refreshToken,
    });
  }

  async validateAccessToken(token: string): Promise<AuthenticatedUser> {
    // Check if token is blacklisted
    if (await this.blacklistManager.isTokenBlacklisted(token)) {
      throw new AuthenticationError('Token has been revoked');
    }

    const payload = this.jwtManager.verifyAccessToken(token);
    
    const user = await this.userRepo.findById(payload.sub);
    if (!user) {
      throw new AuthenticationError('User not found');
    }

    return user;
  }
}
```

**Critérios de Aceitação:**
- [x] Auth service completo implementado
- [x] Login, logout, refresh e validação funcionando
- [x] Integração com audit logging
- [x] Error handling consistente

---

### - [x] SUB-SEC-002-06: [15min] Atualizar Auth Module Exports

**Arquivos a modificar:**
- `packages/security/src/auth/index.ts`

**Implementação:**
```typescript
// auth/index.ts
// Core JWT functionality
export { JwtManager } from './jwt';
export { AuthService } from './service';
export { TokenBlacklistManager, MemoryTokenBlacklist } from './blacklist';

// Types and interfaces
export type {
  JwtPayload,
  JwtConfig,
  AuthTokens,
  AuthenticatedUser,
  LoginCredentials,
  LoginResult,
  RefreshTokenRequest,
  LogoutRequest,
  IUserRepository,
  ISessionRepository,
} from './types';

// Utilities and constants
export * from './utils';

// Re-export for convenience
export { AUTH_CONSTANTS } from './utils';
```

**Critérios de Aceitação:**
- [x] Todos os exports organizados e funcionando
- [x] Types e implementações disponíveis
- [x] Tree-shaking compatibility mantida

**Comando de Validação:**
```bash
cd packages/security && pnpm type-check
```

---

## Phase 2: Authentication Middleware (1.5h)

**Progress**: 6/6 subtasks concluídas ⏳

### - [x] SUB-SEC-002-07: [15min] Implementar Express Auth Middleware

**Arquivos a criar:**
- `packages/security/src/auth/middleware.ts`

**Implementação:**
```typescript
// auth/middleware.ts
import type { Request, Response, NextFunction } from 'express';
import { AuthService } from './service';
import { extractBearerToken, createSecurityContext } from '../middleware/utils';
import { AuthenticationError } from '../types/errors.types';
import { securityLogger } from '../utils';
import type { AuthenticatedUser } from './types';

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      user?: AuthenticatedUser;
      authContext?: {
        token: string;
        isAuthenticated: boolean;
        sessionId?: string;
      };
    }
  }
}

export function createAuthMiddleware(authService: AuthService) {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const token = extractBearerToken(req);
      
      if (!token) {
        req.authContext = { token: '', isAuthenticated: false };
        throw new AuthenticationError('No authentication token provided', {
          code: 'MISSING_TOKEN',
        });
      }

      // Validate token and get user
      const user = await authService.validateAccessToken(token);
      
      // Attach user and context to request
      req.user = user;
      req.authContext = {
        token,
        isAuthenticated: true,
        sessionId: user.sessionId,
      };

      securityLogger.debug('Authentication successful', {
        userId: user.id,
        path: req.path,
        method: req.method,
      });

      next();
    } catch (error) {
      if (error instanceof AuthenticationError) {
        securityLogger.warn('Authentication failed', {
          path: req.path,
          method: req.method,
          error: error.message,
          code: error.code,
        });

        res.status(error.statusCode).json({
          error: {
            code: error.code,
            message: error.message,
            timestamp: error.timestamp,
          },
        });
        return;
      }

      securityLogger.error('Authentication middleware error', {
        path: req.path,
        method: req.method,
        error: error instanceof Error ? error.message : 'Unknown error',
      });

      res.status(500).json({
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Authentication failed',
        },
      });
    }
  };
}

export function requireAuth(authService: AuthService) {
  const authMiddleware = createAuthMiddleware(authService);
  
  return (req: Request, res: Response, next: NextFunction): void => {
    authMiddleware(req, res, (error) => {
      if (error || !req.authContext?.isAuthenticated) {
        return;
      }
      next();
    });
  };
}

export function optionalAuth(authService: AuthService) {
  const authMiddleware = createAuthMiddleware(authService);
  
  return (req: Request, res: Response, next: NextFunction): void => {
    authMiddleware(req, res, (error) => {
      // Continue regardless of authentication status
      next();
    });
  };
}
```

**Critérios de Aceitação:**
- [x] Middleware Express para autenticação obrigatória e opcional
- [x] Extensão do Request type com user e authContext
- [x] Error handling consistente com SecurityError
- [x] Logging adequado de eventos de autenticação

---

### - [x] SUB-SEC-002-08: [15min] Implementar Route Protection Helpers

**Arquivos a criar:**
- `packages/security/src/auth/guards.ts`

**Implementação:**
```typescript
// auth/guards.ts
import type { Request, Response, NextFunction } from 'express';
import { AuthorizationError } from '../types/errors.types';
import { securityLogger } from '../utils';
import type { AuthenticatedUser } from './types';

export function requireRole(requiredRole: string) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      return next(new AuthorizationError('Authentication required'));
    }

    if (!req.user.roles.includes(requiredRole)) {
      securityLogger.warn('Role authorization failed', {
        userId: req.user.id,
        requiredRole,
        userRoles: req.user.roles,
        path: req.path,
      });

      return next(new AuthorizationError(`Role '${requiredRole}' required`));
    }

    next();
  };
}

export function requireAnyRole(requiredRoles: string[]) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      return next(new AuthorizationError('Authentication required'));
    }

    const hasRole = requiredRoles.some(role => req.user!.roles.includes(role));
    
    if (!hasRole) {
      securityLogger.warn('Multiple role authorization failed', {
        userId: req.user.id,
        requiredRoles,
        userRoles: req.user.roles,
        path: req.path,
      });

      return next(new AuthorizationError(`One of roles [${requiredRoles.join(', ')}] required`));
    }

    next();
  };
}

export function requirePermission(requiredPermission: string) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      return next(new AuthorizationError('Authentication required'));
    }

    if (!req.user.permissions.includes(requiredPermission)) {
      securityLogger.warn('Permission authorization failed', {
        userId: req.user.id,
        requiredPermission,
        userPermissions: req.user.permissions,
        path: req.path,
      });

      return next(new AuthorizationError(`Permission '${requiredPermission}' required`));
    }

    next();
  };
}

export function requireOwnership(getResourceOwnerId: (req: Request) => string | Promise<string>) {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        return next(new AuthorizationError('Authentication required'));
      }

      const resourceOwnerId = await getResourceOwnerId(req);
      
      if (req.user.id !== resourceOwnerId) {
        securityLogger.warn('Ownership authorization failed', {
          userId: req.user.id,
          resourceOwnerId,
          path: req.path,
        });

        return next(new AuthorizationError('Resource access denied'));
      }

      next();
    } catch (error) {
      next(error);
    }
  };
}

// Utility for checking user capabilities
export function canUser(user: AuthenticatedUser, action: string): boolean {
  return user.permissions.includes(action) || user.roles.includes('admin');
}

export function hasRole(user: AuthenticatedUser, role: string): boolean {
  return user.roles.includes(role);
}

export function hasAnyRole(user: AuthenticatedUser, roles: string[]): boolean {
  return roles.some(role => user.roles.includes(role));
}
```

**Critérios de Aceitação:**
- [x] Guards para role e permission-based authorization
- [x] Ownership guards para recursos específicos
- [x] Utility functions para capability checking
- [x] Logging de falhas de autorização

---

### - [x] SUB-SEC-002-09: [15min] Implementar Auth Route Handlers

**Arquivos a criar:**
- `packages/security/src/auth/handlers.ts`

**Implementação:**
```typescript
// auth/handlers.ts
import type { Request, Response, NextFunction } from 'express';
import { AuthService } from './service';
import { securityLogger } from '../utils';
import { getClientIP, createSecurityContext } from '../middleware/utils';
import type { LoginCredentials, RefreshTokenRequest } from './types';

export function createAuthHandlers(authService: AuthService) {
  
  const login = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { email, password } = req.body;
      
      if (!email || !password) {
        res.status(400).json({
          error: {
            code: 'MISSING_CREDENTIALS',
            message: 'Email and password are required',
          },
        });
        return;
      }

      const credentials: LoginCredentials = {
        email,
        password,
        deviceInfo: {
          userAgent: req.get('User-Agent'),
          ipAddress: getClientIP(req),
        },
      };

      const result = await authService.login(credentials);

      securityLogger.info('User login successful', {
        userId: result.user.id,
        isFirstLogin: result.isFirstLogin,
        deviceInfo: credentials.deviceInfo,
      });

      res.status(200).json({
        success: true,
        data: {
          user: {
            id: result.user.id,
            email: result.user.email,
            roles: result.user.roles,
          },
          tokens: result.tokens,
          isFirstLogin: result.isFirstLogin,
        },
      });
    } catch (error) {
      next(error);
    }
  };

  const refresh = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { refreshToken } = req.body;
      
      if (!refreshToken) {
        res.status(400).json({
          error: {
            code: 'MISSING_REFRESH_TOKEN',
            message: 'Refresh token is required',
          },
        });
        return;
      }

      const refreshRequest: RefreshTokenRequest = {
        refreshToken,
        deviceInfo: {
          userAgent: req.get('User-Agent'),
          ipAddress: getClientIP(req),
        },
      };

      const result = await authService.refreshTokens(refreshRequest);

      res.status(200).json({
        success: true,
        data: {
          user: {
            id: result.user.id,
            email: result.user.email,
            roles: result.user.roles,
          },
          tokens: result.tokens,
        },
      });
    } catch (error) {
      next(error);
    }
  };

  const logout = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        res.status(401).json({
          error: {
            code: 'UNAUTHORIZED',
            message: 'Authentication required',
          },
        });
        return;
      }

      const { refreshToken, logoutAllDevices = false } = req.body;

      await authService.logout(req.user.id, {
        refreshToken,
        logoutAllDevices,
      });

      res.status(200).json({
        success: true,
        message: 'Logged out successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  const me = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        res.status(401).json({
          error: {
            code: 'UNAUTHORIZED',
            message: 'Authentication required',
          },
        });
        return;
      }

      res.status(200).json({
        success: true,
        data: {
          user: {
            id: req.user.id,
            email: req.user.email,
            roles: req.user.roles,
            permissions: req.user.permissions,
            lastLoginAt: req.user.lastLoginAt,
          },
          session: {
            sessionId: req.authContext?.sessionId,
            isAuthenticated: req.authContext?.isAuthenticated || false,
          },
        },
      });
    } catch (error) {
      next(error);
    }
  };

  return {
    login,
    refresh,
    logout,
    me,
  };
}
```

**Critérios de Aceitação:**
- [x] Route handlers para login, refresh, logout e profile
- [x] Request validation e error handling
- [x] Structured responses com success/error patterns
- [x] Device info tracking em requests

---

### - [x] SUB-SEC-002-10: [15min] Criar Database Abstraction Layer

**Arquivos a criar:**
- `packages/security/src/auth/database.ts`

**Implementação:**
```typescript
// auth/database.ts
import { createChildLogger } from '../utils';
import type { IUserRepository, ISessionRepository, AuthenticatedUser } from './types';

const logger = createChildLogger({ component: 'auth-database' });

// Mock implementations for development/testing
export class MockUserRepository implements IUserRepository {
  private users: Map<string, AuthenticatedUser & { password: string }> = new Map();

  constructor() {
    // Add default admin user for testing
    this.users.set('admin@example.com', {
      id: '1',
      email: 'admin@example.com',
      roles: ['admin', 'user'],
      permissions: ['user:read', 'user:write', 'admin:all'],
      sessionId: '',
      lastLoginAt: new Date(),
      password: '$2b$12$9Ol5P8mO1Hj8GQZ9r.E9ZuTn7xKJ1a2e4r5t6y7u8i9o0p1q2w3e4r5', // "password123"
    });
  }

  async findByEmail(email: string): Promise<AuthenticatedUser | null> {
    const user = this.users.get(email);
    if (!user) return null;

    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  async findById(id: string): Promise<AuthenticatedUser | null> {
    for (const user of this.users.values()) {
      if (user.id === id) {
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
      }
    }
    return null;
  }

  async updateLastLogin(id: string): Promise<void> {
    for (const [email, user] of this.users.entries()) {
      if (user.id === id) {
        user.lastLoginAt = new Date();
        this.users.set(email, user);
        break;
      }
    }
  }

  async validatePassword(email: string, password: string): Promise<boolean> {
    const user = this.users.get(email);
    if (!user) return false;

    // In real implementation, use bcrypt.compare
    // For mock, simple comparison (in production, never store plain passwords)
    return user.password === '$2b$12$9Ol5P8mO1Hj8GQZ9r.E9ZuTn7xKJ1a2e4r5t6y7u8i9o0p1q2w3e4r5' && password === 'password123';
  }
}

export class MockSessionRepository implements ISessionRepository {
  private sessions = new Map<string, { userId: string; refreshToken: string; deviceInfo?: any }>();
  private blacklistedTokens = new Map<string, Date>();

  async createSession(userId: string, refreshToken: string, deviceInfo?: any): Promise<string> {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    this.sessions.set(sessionId, {
      userId,
      refreshToken,
      deviceInfo,
    });

    logger.debug('Session created', { sessionId, userId });
    return sessionId;
  }

  async findSession(sessionId: string): Promise<{ userId: string; refreshToken: string } | null> {
    const session = this.sessions.get(sessionId);
    return session ? { userId: session.userId, refreshToken: session.refreshToken } : null;
  }

  async revokeSession(sessionId: string): Promise<void> {
    this.sessions.delete(sessionId);
    logger.debug('Session revoked', { sessionId });
  }

  async revokeAllUserSessions(userId: string): Promise<void> {
    for (const [sessionId, session] of this.sessions.entries()) {
      if (session.userId === userId) {
        this.sessions.delete(sessionId);
      }
    }
    logger.debug('All user sessions revoked', { userId });
  }

  async isTokenBlacklisted(token: string): Promise<boolean> {
    const expiry = this.blacklistedTokens.get(token);
    if (!expiry) return false;

    if (expiry <= new Date()) {
      this.blacklistedTokens.delete(token);
      return false;
    }

    return true;
  }

  async blacklistToken(token: string, expiresAt: Date): Promise<void> {
    this.blacklistedTokens.set(token, expiresAt);
    logger.debug('Token blacklisted', { tokenHash: token.substring(0, 8) + '...', expiresAt });
  }
}

// Factory functions for easy setup
export function createMockDatabaseRepositories(): {
  userRepo: IUserRepository;
  sessionRepo: ISessionRepository;
} {
  return {
    userRepo: new MockUserRepository(),
    sessionRepo: new MockSessionRepository(),
  };
}

// Database abstraction factory (for future CORE-001 integration)
export interface DatabaseConfig {
  type: 'mock' | 'prisma' | 'custom';
  prismaClient?: any; // Will be properly typed when CORE-001 is available
  customRepositories?: {
    userRepo: IUserRepository;
    sessionRepo: ISessionRepository;
  };
}

export function createDatabaseRepositories(config: DatabaseConfig): {
  userRepo: IUserRepository;
  sessionRepo: ISessionRepository;
} {
  switch (config.type) {
    case 'mock':
      return createMockDatabaseRepositories();
    
    case 'custom':
      if (!config.customRepositories) {
        throw new Error('Custom repositories must be provided when type is "custom"');
      }
      return config.customRepositories;
    
    case 'prisma':
      // Will be implemented when CORE-001 is available
      throw new Error('Prisma integration not yet available. Use mock or custom repositories.');
    
    default:
      throw new Error(`Unsupported database type: ${config.type}`);
  }
}
```

**Critérios de Aceitação:**
- [x] Mock repositories implementados para desenvolvimento
- [x] Database abstraction layer preparado para CORE-001
- [x] Factory functions para easy setup
- [x] Logging adequado de operações

---

### - [x] SUB-SEC-002-11: [15min] Configurar Auth Setup Utilities

**Arquivos a criar:**
- `packages/security/src/auth/setup.ts`

**Implementação:**
```typescript
// auth/setup.ts
import { AuthService } from './service';
import { createAuthMiddleware, requireAuth, optionalAuth } from './middleware';
import { createAuthHandlers } from './handlers';
import { createDatabaseRepositories } from './database';
import type { JwtConfig, DatabaseConfig, IUserRepository, ISessionRepository } from './types';
import { securityLogger } from '../utils';

export interface AuthSetupConfig {
  jwt: JwtConfig;
  database: DatabaseConfig;
}

export interface AuthSetup {
  authService: AuthService;
  middleware: {
    auth: ReturnType<typeof createAuthMiddleware>;
    requireAuth: ReturnType<typeof requireAuth>;
    optionalAuth: ReturnType<typeof optionalAuth>;
  };
  handlers: ReturnType<typeof createAuthHandlers>;
  repositories: {
    userRepo: IUserRepository;
    sessionRepo: ISessionRepository;
  };
}

export function setupAuthentication(config: AuthSetupConfig): AuthSetup {
  securityLogger.info('Setting up authentication system', {
    jwtAlgorithm: config.jwt.algorithm,
    databaseType: config.database.type,
  });

  // Create database repositories
  const repositories = createDatabaseRepositories(config.database);

  // Create auth service
  const authService = new AuthService(
    config.jwt,
    repositories.userRepo,
    repositories.sessionRepo
  );

  // Create middleware
  const middleware = {
    auth: createAuthMiddleware(authService),
    requireAuth: requireAuth(authService),
    optionalAuth: optionalAuth(authService),
  };

  // Create route handlers
  const handlers = createAuthHandlers(authService);

  securityLogger.info('Authentication system setup complete');

  return {
    authService,
    middleware,
    handlers,
    repositories,
  };
}

// Convenient setup with defaults for development
export function setupDevAuthentication(jwtSecret?: string): AuthSetup {
  const defaultConfig: AuthSetupConfig = {
    jwt: {
      secret: jwtSecret || 'dev-secret-key-change-in-production-min-32-chars',
      expiresIn: '15m',
      refreshExpiresIn: '7d',
      algorithm: 'HS256',
    },
    database: {
      type: 'mock',
    },
  };

  return setupAuthentication(defaultConfig);
}

// Express router setup helper
export function createAuthRouter(authSetup: AuthSetup) {
  const { Router } = require('express');
  const router = Router();

  // Auth routes
  router.post('/login', authSetup.handlers.login);
  router.post('/refresh', authSetup.handlers.refresh);
  router.post('/logout', authSetup.middleware.requireAuth, authSetup.handlers.logout);
  router.get('/me', authSetup.middleware.requireAuth, authSetup.handlers.me);

  return router;
}
```

**Critérios de Aceitação:**
- [x] Setup utilities para fácil integração
- [x] Configuration management estruturado
- [x] Development defaults para quick start
- [x] Express router helper implementado

---

### - [x] SUB-SEC-002-12: [15min] Atualizar Middleware Module Exports

**Arquivos a modificar:**
- `packages/security/src/middleware/index.ts`

**Implementação:**
```typescript
// middleware/index.ts
// Express middleware utilities
export * from './utils';
export * from './types';

// Authentication middleware (from auth module)
export { 
  createAuthMiddleware, 
  requireAuth, 
  optionalAuth 
} from '../auth/middleware';

// Authorization guards (from auth module)
export {
  requireRole,
  requireAnyRole,
  requirePermission,
  requireOwnership,
  canUser,
  hasRole,
  hasAnyRole,
} from '../auth/guards';

// Auth setup utilities
export { setupAuthentication, setupDevAuthentication, createAuthRouter } from '../auth/setup';

// For convenience, re-export key auth types
export type {
  AuthenticatedUser,
  JwtConfig,
  AuthSetupConfig,
  AuthSetup,
} from '../auth/types';
```

**Critérios de Aceitação:**
- [x] Middleware exports organizados e completos
- [x] Auth integration disponível via middleware module
- [x] Types re-exportados para conveniência
- [x] Exports testados e funcionando

**Comando de Validação:**
```bash
cd packages/security && pnpm type-check && pnpm build
```

---

## Phase 3: Database Integration (2h)

**Progress**: 0/8 subtasks concluídas ⏳

### - [x] SUB-SEC-002-13: [15min] Implementar Password Hashing Integration

**Arquivos a modificar:**
- `packages/security/src/auth/database.ts` (expandir MockUserRepository)

**Implementação:**
```typescript
// auth/database.ts (adicionar ao MockUserRepository)
import { hashPassword, verifyPassword } from '../password/utils';

export class MockUserRepository implements IUserRepository {
  // ... código anterior

  async validatePassword(email: string, password: string): Promise<boolean> {
    const user = this.users.get(email);
    if (!user) return false;

    try {
      return await verifyPassword(password, user.password);
    } catch (error) {
      logger.error('Password validation error', { email, error });
      return false;
    }
  }

  // New method for user creation (useful for testing)
  async createUser(userData: {
    email: string;
    password: string;
    roles?: string[];
    permissions?: string[];
  }): Promise<AuthenticatedUser> {
    const { email, password, roles = ['user'], permissions = ['user:read'] } = userData;
    
    if (this.users.has(email)) {
      throw new Error('User already exists');
    }

    const hashedPassword = await hashPassword(password);
    const id = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const user = {
      id,
      email,
      roles,
      permissions,
      sessionId: '',
      lastLoginAt: new Date(),
      password: hashedPassword,
    };

    this.users.set(email, user);
    
    const { password: _, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  // Method to list users (useful for admin features)
  async listUsers(): Promise<Omit<AuthenticatedUser, 'sessionId'>[]> {
    return Array.from(this.users.values()).map(user => {
      const { password, sessionId, ...userWithoutSensitive } = user;
      return userWithoutSensitive;
    });
  }
}

// Update interface to include new methods
export interface IUserRepository {
  findByEmail(email: string): Promise<AuthenticatedUser | null>;
  findById(id: string): Promise<AuthenticatedUser | null>;
  updateLastLogin(id: string): Promise<void>;
  validatePassword(email: string, password: string): Promise<boolean>;
  createUser?(userData: {
    email: string;
    password: string;
    roles?: string[];
    permissions?: string[];
  }): Promise<AuthenticatedUser>;
  listUsers?(): Promise<Omit<AuthenticatedUser, 'sessionId'>[]>;
}
```

**Critérios de Aceitação:**
- [x] Password hashing integrado com bcrypt utilities
- [x] User creation method implementado
- [x] Error handling para password operations
- [x] Optional methods para admin features

---

### - [x] SUB-SEC-002-14: [15min] Implementar Session Management com Redis Pattern

**Arquivos a modificar:**
- `packages/security/src/auth/database.ts` (expandir MockSessionRepository)

**Implementação:**
```typescript
// auth/database.ts (expandir MockSessionRepository)
export class MockSessionRepository implements ISessionRepository {
  private sessions = new Map<string, {
    userId: string;
    refreshToken: string;
    deviceInfo?: any;
    createdAt: Date;
    lastAccessedAt: Date;
  }>();
  private blacklistedTokens = new Map<string, Date>();
  private userSessions = new Map<string, Set<string>>(); // userId -> sessionIds

  async createSession(userId: string, refreshToken: string, deviceInfo?: any): Promise<string> {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date();
    
    this.sessions.set(sessionId, {
      userId,
      refreshToken,
      deviceInfo,
      createdAt: now,
      lastAccessedAt: now,
    });

    // Track user sessions
    if (!this.userSessions.has(userId)) {
      this.userSessions.set(userId, new Set());
    }
    this.userSessions.get(userId)!.add(sessionId);

    logger.debug('Session created', { 
      sessionId, 
      userId, 
      deviceInfo: deviceInfo ? {
        userAgent: deviceInfo.userAgent?.substring(0, 50),
        ipAddress: deviceInfo.ipAddress,
      } : undefined 
    });
    
    return sessionId;
  }

  async findSession(sessionId: string): Promise<{ userId: string; refreshToken: string } | null> {
    const session = this.sessions.get(sessionId);
    if (!session) return null;

    // Update last accessed time
    session.lastAccessedAt = new Date();
    this.sessions.set(sessionId, session);

    return { 
      userId: session.userId, 
      refreshToken: session.refreshToken 
    };
  }

  async updateSessionToken(sessionId: string, newRefreshToken: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.refreshToken = newRefreshToken;
      session.lastAccessedAt = new Date();
      this.sessions.set(sessionId, session);
    }
  }

  async revokeSession(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (session) {
      // Remove from user sessions tracking
      const userSessionIds = this.userSessions.get(session.userId);
      if (userSessionIds) {
        userSessionIds.delete(sessionId);
        if (userSessionIds.size === 0) {
          this.userSessions.delete(session.userId);
        }
      }
    }
    
    this.sessions.delete(sessionId);
    logger.debug('Session revoked', { sessionId });
  }

  async revokeAllUserSessions(userId: string): Promise<void> {
    const sessionIds = this.userSessions.get(userId);
    if (sessionIds) {
      for (const sessionId of sessionIds) {
        this.sessions.delete(sessionId);
      }
      this.userSessions.delete(userId);
    }
    
    logger.debug('All user sessions revoked', { userId, sessionCount: sessionIds?.size || 0 });
  }

  async getUserActiveSessions(userId: string): Promise<Array<{
    sessionId: string;
    deviceInfo?: any;
    createdAt: Date;
    lastAccessedAt: Date;
  }>> {
    const sessionIds = this.userSessions.get(userId);
    if (!sessionIds) return [];

    const activeSessions = [];
    for (const sessionId of sessionIds) {
      const session = this.sessions.get(sessionId);
      if (session) {
        activeSessions.push({
          sessionId,
          deviceInfo: session.deviceInfo,
          createdAt: session.createdAt,
          lastAccessedAt: session.lastAccessedAt,
        });
      }
    }

    return activeSessions;
  }

  async cleanupExpiredSessions(): Promise<number> {
    const now = new Date();
    const expiredCutoff = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); // 7 days
    let cleanedCount = 0;

    for (const [sessionId, session] of this.sessions.entries()) {
      if (session.lastAccessedAt < expiredCutoff) {
        await this.revokeSession(sessionId);
        cleanedCount++;
      }
    }

    logger.info('Expired sessions cleaned up', { cleanedCount });
    return cleanedCount;
  }

  // ... blacklist methods remain the same
}

// Update interface
export interface ISessionRepository {
  createSession(userId: string, refreshToken: string, deviceInfo?: any): Promise<string>;
  findSession(sessionId: string): Promise<{ userId: string; refreshToken: string } | null>;
  updateSessionToken?(sessionId: string, newRefreshToken: string): Promise<void>;
  revokeSession(sessionId: string): Promise<void>;
  revokeAllUserSessions(userId: string): Promise<void>;
  getUserActiveSessions?(userId: string): Promise<Array<{
    sessionId: string;
    deviceInfo?: any;
    createdAt: Date;
    lastAccessedAt: Date;
  }>>;
  cleanupExpiredSessions?(): Promise<number>;
  isTokenBlacklisted(token: string): Promise<boolean>;
  blacklistToken(token: string, expiresAt: Date): Promise<void>;
}
```

**Critérios de Aceitação:**
- [x] Session tracking por usuário implementado
- [x] Session metadata (device info, timestamps) armazenado
- [x] Cleanup de sessões expiradas
- [x] Methods para listar sessões ativas do usuário

---

### - [x] SUB-SEC-002-15: [15min] Implementar User Registration Service

**Arquivos a criar:**
- `packages/security/src/auth/registration.ts`

**Implementação:**
```typescript
// auth/registration.ts
import { generateSecureUUID } from '../utils/crypto';
import { isValidEmail, isValidPassword } from '../utils/validation';
import { AuthenticationError } from '../types/errors.types';
import { auditLog, securityLogger } from '../utils';
import type { IUserRepository, AuthenticatedUser } from './types';

export interface RegistrationData {
  email: string;
  password: string;
  confirmPassword: string;
  firstName?: string;
  lastName?: string;
  roles?: string[];
  permissions?: string[];
}

export interface RegistrationResult {
  user: Omit<AuthenticatedUser, 'sessionId'>;
  requiresVerification: boolean;
}

export class RegistrationService {
  constructor(
    private userRepo: IUserRepository,
    private config: {
      requireEmailVerification?: boolean;
      defaultRoles?: string[];
      defaultPermissions?: string[];
      allowedRoles?: string[];
    } = {}
  ) {}

  async registerUser(data: RegistrationData): Promise<RegistrationResult> {
    const {
      email,
      password,
      confirmPassword,
      firstName,
      lastName,
      roles = this.config.defaultRoles || ['user'],
      permissions = this.config.defaultPermissions || ['user:read']
    } = data;

    // Validation
    await this.validateRegistrationData(data);

    // Check if user already exists
    const existingUser = await this.userRepo.findByEmail(email);
    if (existingUser) {
      auditLog('registration_failed', { 
        email, 
        reason: 'user_already_exists' 
      });
      throw new AuthenticationError('User already exists', {
        code: 'USER_ALREADY_EXISTS',
      });
    }

    // Filter roles to only allowed ones
    const filteredRoles = this.filterAllowedRoles(roles);

    // Create user
    const user = await this.userRepo.createUser!({
      email,
      password,
      roles: filteredRoles,
      permissions,
    });

    auditLog('user_registered', {
      userId: user.id,
      email: user.email,
      roles: user.roles,
      requiresVerification: this.config.requireEmailVerification || false,
    });

    securityLogger.info('User registered successfully', {
      userId: user.id,
      email: user.email,
      roles: user.roles,
    });

    return {
      user,
      requiresVerification: this.config.requireEmailVerification || false,
    };
  }

  private async validateRegistrationData(data: RegistrationData): Promise<void> {
    const { email, password, confirmPassword } = data;

    if (!email || !isValidEmail(email)) {
      throw new AuthenticationError('Valid email is required', {
        code: 'INVALID_EMAIL',
      });
    }

    if (!password) {
      throw new AuthenticationError('Password is required', {
        code: 'PASSWORD_REQUIRED',
      });
    }

    if (password !== confirmPassword) {
      throw new AuthenticationError('Passwords do not match', {
        code: 'PASSWORD_MISMATCH',
      });
    }

    const passwordValidation = isValidPassword(password);
    if (!passwordValidation.isValid) {
      throw new AuthenticationError('Password does not meet requirements', {
        code: 'WEAK_PASSWORD',
        details: passwordValidation.errors,
      });
    }
  }

  private filterAllowedRoles(requestedRoles: string[]): string[] {
    if (!this.config.allowedRoles) {
      return requestedRoles;
    }

    return requestedRoles.filter(role => 
      this.config.allowedRoles!.includes(role)
    );
  }

  async initiateEmailVerification(userId: string): Promise<string> {
    // Generate verification token
    const verificationToken = generateSecureUUID();
    
    // In real implementation, store token in database with expiration
    // For now, just log it
    securityLogger.info('Email verification initiated', {
      userId,
      verificationToken,
    });

    auditLog('email_verification_initiated', { userId });

    return verificationToken;
  }

  async verifyEmail(userId: string, token: string): Promise<boolean> {
    // In real implementation, validate token against database
    // For now, just audit the attempt
    auditLog('email_verification_attempt', { userId, token });
    
    securityLogger.info('Email verification completed', { userId });
    
    return true;
  }

  async resendVerificationEmail(email: string): Promise<boolean> {
    const user = await this.userRepo.findByEmail(email);
    if (!user) {
      // Don't reveal if email exists
      return true;
    }

    const token = await this.initiateEmailVerification(user.id);
    
    auditLog('email_verification_resent', { 
      userId: user.id,
      email: user.email 
    });

    return true;
  }
}
```

**Critérios de Aceitação:**
- [x] User registration com validação completa
- [x] Email verification workflow implementado
- [x] Role filtering para security
- [x] Audit logging de registration events

---

### - [x] SUB-SEC-002-16: [15min] Implementar Password Reset Service

**Arquivos a criar:**
- `packages/security/src/auth/password-reset.ts`

**Implementação:**
```typescript
// auth/password-reset.ts
import { generateSecureUUID } from '../utils/crypto';
import { isValidPassword } from '../utils/validation';
import { hashPassword } from '../password/utils';
import { AuthenticationError } from '../types/errors.types';
import { auditLog, securityLogger } from '../utils';
import type { IUserRepository, ISessionRepository } from './types';

export interface PasswordResetRequest {
  email: string;
  ipAddress?: string;
  userAgent?: string;
}

export interface PasswordResetConfirm {
  token: string;
  newPassword: string;
  confirmPassword: string;
}

export class PasswordResetService {
  private resetTokens = new Map<string, {
    userId: string;
    email: string;
    expiresAt: Date;
    used: boolean;
  }>();

  constructor(
    private userRepo: IUserRepository,
    private sessionRepo: ISessionRepository,
    private config: {
      tokenExpirationMinutes?: number;
      revokeSessionsOnReset?: boolean;
    } = {}
  ) {}

  async initiatePasswordReset(request: PasswordResetRequest): Promise<boolean> {
    const { email, ipAddress, userAgent } = request;

    // Always return true to prevent email enumeration
    // But only actually send email if user exists
    const user = await this.userRepo.findByEmail(email);
    
    auditLog('password_reset_requested', {
      email,
      userExists: !!user,
      ipAddress,
      userAgent,
    });

    if (!user) {
      // Fake delay to prevent timing attacks
      await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));
      return true;
    }

    // Generate reset token
    const token = generateSecureUUID();
    const expiresAt = new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + (this.config.tokenExpirationMinutes || 30));

    this.resetTokens.set(token, {
      userId: user.id,
      email: user.email,
      expiresAt,
      used: false,
    });

    securityLogger.info('Password reset token generated', {
      userId: user.id,
      email: user.email,
      expiresAt,
    });

    // In real implementation, send email here
    // For now, just log the token (remove in production)
    securityLogger.debug('Password reset token (DEV ONLY)', { token });

    return true;
  }

  async confirmPasswordReset(confirm: PasswordResetConfirm): Promise<boolean> {
    const { token, newPassword, confirmPassword } = confirm;

    // Validate token
    const resetData = this.resetTokens.get(token);
    if (!resetData) {
      auditLog('password_reset_failed', { 
        token: token.substring(0, 8) + '...', 
        reason: 'invalid_token' 
      });
      throw new AuthenticationError('Invalid or expired reset token', {
        code: 'INVALID_RESET_TOKEN',
      });
    }

    if (resetData.used) {
      auditLog('password_reset_failed', { 
        userId: resetData.userId,
        reason: 'token_already_used' 
      });
      throw new AuthenticationError('Reset token has already been used', {
        code: 'TOKEN_ALREADY_USED',
      });
    }

    if (resetData.expiresAt <= new Date()) {
      this.resetTokens.delete(token);
      auditLog('password_reset_failed', { 
        userId: resetData.userId,
        reason: 'token_expired' 
      });
      throw new AuthenticationError('Reset token has expired', {
        code: 'TOKEN_EXPIRED',
      });
    }

    // Validate new password
    if (newPassword !== confirmPassword) {
      throw new AuthenticationError('Passwords do not match', {
        code: 'PASSWORD_MISMATCH',
      });
    }

    const passwordValidation = isValidPassword(newPassword);
    if (!passwordValidation.isValid) {
      throw new AuthenticationError('Password does not meet requirements', {
        code: 'WEAK_PASSWORD',
        details: passwordValidation.errors,
      });
    }

    // Get user and update password
    const user = await this.userRepo.findById(resetData.userId);
    if (!user) {
      throw new AuthenticationError('User not found', {
        code: 'USER_NOT_FOUND',
      });
    }

    // In real implementation, update password in database
    // For mock, we'll simulate this
    const hashedPassword = await hashPassword(newPassword);
    
    // Mark token as used
    resetData.used = true;
    this.resetTokens.set(token, resetData);

    // Optionally revoke all existing sessions
    if (this.config.revokeSessionsOnReset !== false) {
      await this.sessionRepo.revokeAllUserSessions(user.id);
    }

    auditLog('password_reset_successful', {
      userId: user.id,
      email: user.email,
      sessionsRevoked: this.config.revokeSessionsOnReset !== false,
    });

    securityLogger.info('Password reset completed', {
      userId: user.id,
      email: user.email,
    });

    return true;
  }

  async validateResetToken(token: string): Promise<boolean> {
    const resetData = this.resetTokens.get(token);
    
    if (!resetData || resetData.used || resetData.expiresAt <= new Date()) {
      return false;
    }

    return true;
  }

  async cleanupExpiredTokens(): Promise<number> {
    const now = new Date();
    let cleanupCount = 0;

    for (const [token, data] of this.resetTokens.entries()) {
      if (data.expiresAt <= now || data.used) {
        this.resetTokens.delete(token);
        cleanupCount++;
      }
    }

    if (cleanupCount > 0) {
      securityLogger.debug('Cleaned up expired reset tokens', { cleanupCount });
    }

    return cleanupCount;
  }

  // Method to revoke a specific reset token (useful for security)
  async revokeResetToken(token: string): Promise<boolean> {
    const resetData = this.resetTokens.get(token);
    if (!resetData) return false;

    this.resetTokens.delete(token);
    
    auditLog('password_reset_token_revoked', {
      userId: resetData.userId,
      email: resetData.email,
    });

    return true;
  }
}
```

**Critérios de Aceitação:**
- [x] Password reset workflow seguro implementado
- [x] Protection contra timing attacks e email enumeration
- [x] Token expiration e cleanup automático
- [x] Session revocation opcional no reset

---

### - [x] SUB-SEC-002-17: [15min] Expandir Auth Service com Registration e Reset

**Arquivos a modificar:**
- `packages/security/src/auth/service.ts`

**Implementação:**
```typescript
// auth/service.ts (adicionar imports e expandir classe)
import { RegistrationService } from './registration';
import { PasswordResetService } from './password-reset';

export class AuthService {
  private jwtManager: JwtManager;
  private blacklistManager: TokenBlacklistManager;
  private registrationService: RegistrationService;
  private passwordResetService: PasswordResetService;

  constructor(
    private config: JwtConfig,
    private userRepo: IUserRepository,
    private sessionRepo: ISessionRepository,
    private options: {
      registration?: {
        requireEmailVerification?: boolean;
        defaultRoles?: string[];
        defaultPermissions?: string[];
        allowedRoles?: string[];
      };
      passwordReset?: {
        tokenExpirationMinutes?: number;
        revokeSessionsOnReset?: boolean;
      };
    } = {}
  ) {
    this.jwtManager = new JwtManager(config);
    this.blacklistManager = new TokenBlacklistManager(sessionRepo);
    
    this.registrationService = new RegistrationService(
      userRepo,
      options.registration || {}
    );
    
    this.passwordResetService = new PasswordResetService(
      userRepo,
      sessionRepo,
      options.passwordReset || {}
    );
  }

  // ... existing methods (login, refresh, logout, validateAccessToken)

  // Registration methods
  async register(data: RegistrationData): Promise<RegistrationResult> {
    return await this.registrationService.registerUser(data);
  }

  async initiateEmailVerification(userId: string): Promise<string> {
    return await this.registrationService.initiateEmailVerification(userId);
  }

  async verifyEmail(userId: string, token: string): Promise<boolean> {
    return await this.registrationService.verifyEmail(userId, token);
  }

  async resendVerificationEmail(email: string): Promise<boolean> {
    return await this.registrationService.resendVerificationEmail(email);
  }

  // Password reset methods
  async initiatePasswordReset(request: PasswordResetRequest): Promise<boolean> {
    return await this.passwordResetService.initiatePasswordReset(request);
  }

  async confirmPasswordReset(confirm: PasswordResetConfirm): Promise<boolean> {
    return await this.passwordResetService.confirmPasswordReset(confirm);
  }

  async validateResetToken(token: string): Promise<boolean> {
    return await this.passwordResetService.validateResetToken(token);
  }

  // Session management methods
  async getUserActiveSessions(userId: string): Promise<Array<{
    sessionId: string;
    deviceInfo?: any;
    createdAt: Date;
    lastAccessedAt: Date;
  }>> {
    if (this.sessionRepo.getUserActiveSessions) {
      return await this.sessionRepo.getUserActiveSessions(userId);
    }
    return [];
  }

  async revokeUserSession(userId: string, sessionId: string): Promise<void> {
    await this.sessionRepo.revokeSession(sessionId);
    
    auditLog('session_revoked', {
      userId,
      sessionId,
      revokedBy: 'user',
    });
  }

  // Maintenance methods
  async performMaintenance(): Promise<{
    sessionsCleanedUp: number;
    resetTokensCleanedUp: number;
  }> {
    const [sessionsCleanedUp, resetTokensCleanedUp] = await Promise.all([
      this.sessionRepo.cleanupExpiredSessions?.() || 0,
      this.passwordResetService.cleanupExpiredTokens(),
    ]);

    securityLogger.info('Auth maintenance completed', {
      sessionsCleanedUp,
      resetTokensCleanedUp,
    });

    return {
      sessionsCleanedUp,
      resetTokensCleanedUp,
    };
  }

  // Security methods
  async changePassword(
    userId: string, 
    currentPassword: string, 
    newPassword: string
  ): Promise<boolean> {
    const user = await this.userRepo.findById(userId);
    if (!user) {
      throw new AuthenticationError('User not found');
    }

    const isCurrentPasswordValid = await this.userRepo.validatePassword(user.email, currentPassword);
    if (!isCurrentPasswordValid) {
      auditLog('password_change_failed', { 
        userId, 
        reason: 'invalid_current_password' 
      });
      throw new AuthenticationError('Current password is incorrect');
    }

    const passwordValidation = isValidPassword(newPassword);
    if (!passwordValidation.isValid) {
      throw new AuthenticationError('New password does not meet requirements', {
        code: 'WEAK_PASSWORD',
        details: passwordValidation.errors,
      });
    }

    // In real implementation, update password in database
    // For now, just audit the change
    auditLog('password_changed', { userId });
    
    // Optionally revoke other sessions
    await this.sessionRepo.revokeAllUserSessions(userId);

    return true;
  }
}

// Export additional types for registration and password reset
export type { RegistrationData, RegistrationResult } from './registration';
export type { PasswordResetRequest, PasswordResetConfirm } from './password-reset';
```

**Critérios de Aceitação:**
- [x] Auth service expandido com registration e password reset
- [x] Session management methods adicionados
- [x] Maintenance utilities implementados
- [x] Password change functionality incluído

---

### - [x] SUB-SEC-002-18: [15min] Criar Route Handlers para Registration e Reset

**Arquivos a modificar:**
- `packages/security/src/auth/handlers.ts`

**Implementação:**
```typescript
// auth/handlers.ts (adicionar handlers)
export function createAuthHandlers(authService: AuthService) {
  // ... existing handlers (login, refresh, logout, me)

  const register = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { email, password, confirmPassword, firstName, lastName } = req.body;
      
      if (!email || !password || !confirmPassword) {
        res.status(400).json({
          error: {
            code: 'MISSING_FIELDS',
            message: 'Email, password, and confirm password are required',
          },
        });
        return;
      }

      const result = await authService.register({
        email,
        password,
        confirmPassword,
        firstName,
        lastName,
      });

      res.status(201).json({
        success: true,
        data: {
          user: {
            id: result.user.id,
            email: result.user.email,
            roles: result.user.roles,
          },
          requiresVerification: result.requiresVerification,
        },
      });
    } catch (error) {
      next(error);
    }
  };

  const initiatePasswordReset = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { email } = req.body;
      
      if (!email) {
        res.status(400).json({
          error: {
            code: 'MISSING_EMAIL',
            message: 'Email is required',
          },
        });
        return;
      }

      await authService.initiatePasswordReset({
        email,
        ipAddress: getClientIP(req),
        userAgent: req.get('User-Agent'),
      });

      // Always return success to prevent email enumeration
      res.status(200).json({
        success: true,
        message: 'If the email exists, a password reset link has been sent',
      });
    } catch (error) {
      next(error);
    }
  };

  const confirmPasswordReset = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { token, newPassword, confirmPassword } = req.body;
      
      if (!token || !newPassword || !confirmPassword) {
        res.status(400).json({
          error: {
            code: 'MISSING_FIELDS',
            message: 'Token, new password, and confirm password are required',
          },
        });
        return;
      }

      await authService.confirmPasswordReset({
        token,
        newPassword,
        confirmPassword,
      });

      res.status(200).json({
        success: true,
        message: 'Password has been reset successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  const validateResetToken = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { token } = req.params;
      
      if (!token) {
        res.status(400).json({
          error: {
            code: 'MISSING_TOKEN',
            message: 'Reset token is required',
          },
        });
        return;
      }

      const isValid = await authService.validateResetToken(token);

      res.status(200).json({
        success: true,
        data: {
          valid: isValid,
        },
      });
    } catch (error) {
      next(error);
    }
  };

  const verifyEmail = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { userId, token } = req.body;
      
      if (!userId || !token) {
        res.status(400).json({
          error: {
            code: 'MISSING_FIELDS',
            message: 'User ID and verification token are required',
          },
        });
        return;
      }

      const verified = await authService.verifyEmail(userId, token);

      res.status(200).json({
        success: true,
        data: {
          verified,
        },
      });
    } catch (error) {
      next(error);
    }
  };

  const resendVerification = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { email } = req.body;
      
      if (!email) {
        res.status(400).json({
          error: {
            code: 'MISSING_EMAIL',
            message: 'Email is required',
          },
        });
        return;
      }

      await authService.resendVerificationEmail(email);

      res.status(200).json({
        success: true,
        message: 'If the email exists, a verification email has been sent',
      });
    } catch (error) {
      next(error);
    }
  };

  const getUserSessions = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        res.status(401).json({
          error: {
            code: 'UNAUTHORIZED',
            message: 'Authentication required',
          },
        });
        return;
      }

      const sessions = await authService.getUserActiveSessions(req.user.id);

      res.status(200).json({
        success: true,
        data: {
          sessions: sessions.map(session => ({
            sessionId: session.sessionId,
            deviceInfo: session.deviceInfo,
            createdAt: session.createdAt,
            lastAccessedAt: session.lastAccessedAt,
            isCurrent: session.sessionId === req.authContext?.sessionId,
          })),
        },
      });
    } catch (error) {
      next(error);
    }
  };

  const revokeSession = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        res.status(401).json({
          error: {
            code: 'UNAUTHORIZED',
            message: 'Authentication required',
          },
        });
        return;
      }

      const { sessionId } = req.params;
      
      if (!sessionId) {
        res.status(400).json({
          error: {
            code: 'MISSING_SESSION_ID',
            message: 'Session ID is required',
          },
        });
        return;
      }

      await authService.revokeUserSession(req.user.id, sessionId);

      res.status(200).json({
        success: true,
        message: 'Session revoked successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  const changePassword = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        res.status(401).json({
          error: {
            code: 'UNAUTHORIZED',
            message: 'Authentication required',
          },
        });
        return;
      }

      const { currentPassword, newPassword } = req.body;
      
      if (!currentPassword || !newPassword) {
        res.status(400).json({
          error: {
            code: 'MISSING_FIELDS',
            message: 'Current password and new password are required',
          },
        });
        return;
      }

      await authService.changePassword(req.user.id, currentPassword, newPassword);

      res.status(200).json({
        success: true,
        message: 'Password changed successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  return {
    // Core auth
    login,
    refresh,
    logout,
    me,
    
    // Registration
    register,
    verifyEmail,
    resendVerification,
    
    // Password reset
    initiatePasswordReset,
    confirmPasswordReset,
    validateResetToken,
    
    // Session management
    getUserSessions,
    revokeSession,
    changePassword,
  };
}
```

**Critérios de Aceitação:**
- [x] Route handlers completos para registration e password reset
- [x] Session management endpoints implementados
- [x] Validation e error handling consistente
- [x] Security considerations em todos os endpoints

---

### - [x] SUB-SEC-002-19: [15min] Atualizar Auth Router com Novas Routes

**Arquivos a modificar:**
- `packages/security/src/auth/setup.ts`

**Implementação:**
```typescript
// auth/setup.ts (atualizar createAuthRouter)
export function createAuthRouter(authSetup: AuthSetup) {
  const { Router } = require('express');
  const router = Router();

  // Core authentication routes
  router.post('/login', authSetup.handlers.login);
  router.post('/refresh', authSetup.handlers.refresh);
  router.post('/logout', authSetup.middleware.requireAuth, authSetup.handlers.logout);
  router.get('/me', authSetup.middleware.requireAuth, authSetup.handlers.me);

  // Registration routes
  router.post('/register', authSetup.handlers.register);
  router.post('/verify-email', authSetup.handlers.verifyEmail);
  router.post('/resend-verification', authSetup.handlers.resendVerification);

  // Password reset routes
  router.post('/password/reset', authSetup.handlers.initiatePasswordReset);
  router.post('/password/confirm', authSetup.handlers.confirmPasswordReset);
  router.get('/password/validate/:token', authSetup.handlers.validateResetToken);

  // Account management routes (require authentication)
  router.get('/sessions', authSetup.middleware.requireAuth, authSetup.handlers.getUserSessions);
  router.delete('/sessions/:sessionId', authSetup.middleware.requireAuth, authSetup.handlers.revokeSession);
  router.post('/password/change', authSetup.middleware.requireAuth, authSetup.handlers.changePassword);

  return router;
}

// Extended setup configuration
export interface AuthSetupConfig {
  jwt: JwtConfig;
  database: DatabaseConfig;
  registration?: {
    requireEmailVerification?: boolean;
    defaultRoles?: string[];
    defaultPermissions?: string[];
    allowedRoles?: string[];
  };
  passwordReset?: {
    tokenExpirationMinutes?: number;
    revokeSessionsOnReset?: boolean;
  };
}

export function setupAuthentication(config: AuthSetupConfig): AuthSetup {
  securityLogger.info('Setting up authentication system', {
    jwtAlgorithm: config.jwt.algorithm,
    databaseType: config.database.type,
    registrationEnabled: !!config.registration,
    passwordResetEnabled: !!config.passwordReset,
  });

  // Create database repositories
  const repositories = createDatabaseRepositories(config.database);

  // Create auth service with extended options
  const authService = new AuthService(
    config.jwt,
    repositories.userRepo,
    repositories.sessionRepo,
    {
      registration: config.registration,
      passwordReset: config.passwordReset,
    }
  );

  // Create middleware
  const middleware = {
    auth: createAuthMiddleware(authService),
    requireAuth: requireAuth(authService),
    optionalAuth: optionalAuth(authService),
  };

  // Create route handlers
  const handlers = createAuthHandlers(authService);

  securityLogger.info('Authentication system setup complete');

  return {
    authService,
    middleware,
    handlers,
    repositories,
  };
}

// Enhanced development setup
export function setupDevAuthentication(jwtSecret?: string): AuthSetup {
  const defaultConfig: AuthSetupConfig = {
    jwt: {
      secret: jwtSecret || 'dev-secret-key-change-in-production-min-32-chars',
      expiresIn: '15m',
      refreshExpiresIn: '7d',
      algorithm: 'HS256',
    },
    database: {
      type: 'mock',
    },
    registration: {
      requireEmailVerification: false,
      defaultRoles: ['user'],
      defaultPermissions: ['user:read'],
      allowedRoles: ['user', 'admin'],
    },
    passwordReset: {
      tokenExpirationMinutes: 30,
      revokeSessionsOnReset: true,
    },
  };

  return setupAuthentication(defaultConfig);
}
```

**Critérios de Aceitação:**
- [x] Router completo com todas as auth routes
- [x] Configuration estendida para registration e reset
- [x] Development setup atualizado
- [x] Setup documentation clara

---

### - [x] SUB-SEC-002-20: [15min] Integrar Password Utilities do SEC-001

**Arquivos a modificar:**
- `packages/security/src/auth/database.ts` (corrigir imports)
- `packages/security/src/auth/password-reset.ts` (corrigir imports)

**Implementação:**
```typescript
// auth/database.ts (adicionar imports corretos)
import { hashPassword, verifyPassword } from '../password/utils';

// auth/password-reset.ts (adicionar imports corretos)
import { hashPassword } from '../password/utils';

// Verificar se password utilities existem, senão criar temporários
// packages/security/src/password/utils.ts (verificar se existe)
export async function hashPassword(password: string): Promise<string> {
  const bcrypt = require('bcrypt');
  const rounds = 12;
  return await bcrypt.hash(password, rounds);
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  const bcrypt = require('bcrypt');
  return await bcrypt.compare(password, hash);
}

export async function generateSalt(rounds: number = 12): Promise<string> {
  const bcrypt = require('bcrypt');
  return await bcrypt.genSalt(rounds);
}
```

**Arquivo a verificar/criar:**
- `packages/security/package.json` (adicionar bcrypt dependency)

**Implementação package.json:**
```json
{
  "dependencies": {
    "bcrypt": "^5.1.1",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/jsonwebtoken": "^9.0.5"
  }
}
```

**Critérios de Aceitação:**
- [x] Password utilities integrados corretamente
- [x] Bcrypt dependency adicionada
- [x] Type definitions incluídas
- [x] Integration testada sem erros de import

---

## Phase 4: Testing e Documentação (1h)

**Progress**: 0/4 subtasks concluídas ⏳

### - [x] SUB-SEC-002-21: [15min] Implementar Testes para JWT Manager

**Arquivos a criar:**
- `packages/security/__tests__/auth/jwt.test.ts`

**Implementação:**
```typescript
// __tests__/auth/jwt.test.ts
import { JwtManager } from '../../src/auth/jwt';
import { AuthenticationError } from '../../src/types/errors.types';

describe('JwtManager', () => {
  let jwtManager: JwtManager;
  const testConfig = {
    secret: 'test-secret-key-min-32-characters-long',
    expiresIn: '15m',
    refreshExpiresIn: '7d',
    algorithm: 'HS256' as const,
  };

  beforeEach(() => {
    jwtManager = new JwtManager(testConfig);
  });

  describe('token generation', () => {
    it('should generate valid access and refresh tokens', () => {
      const payload = {
        sub: 'user123',
        roles: ['user'],
        permissions: ['user:read'],
      };

      const tokens = jwtManager.generateTokens(payload);

      expect(tokens.accessToken).toBeDefined();
      expect(tokens.refreshToken).toBeDefined();
      expect(tokens.tokenType).toBe('Bearer');
      expect(tokens.expiresAt).toBeInstanceOf(Date);
      expect(tokens.expiresAt.getTime()).toBeGreaterThan(Date.now());
    });

    it('should include correct payload in access token', () => {
      const payload = {
        sub: 'user123',
        roles: ['user'],
        permissions: ['user:read'],
      };

      const tokens = jwtManager.generateTokens(payload);
      const decodedPayload = jwtManager.verifyAccessToken(tokens.accessToken);

      expect(decodedPayload.sub).toBe(payload.sub);
      expect(decodedPayload.roles).toEqual(payload.roles);
      expect(decodedPayload.permissions).toEqual(payload.permissions);
      expect(decodedPayload.iat).toBeDefined();
      expect(decodedPayload.exp).toBeDefined();
    });
  });

  describe('token validation', () => {
    it('should validate valid access tokens', () => {
      const payload = {
        sub: 'user123',
        roles: ['user'],
        permissions: ['user:read'],
      };

      const tokens = jwtManager.generateTokens(payload);
      const decodedPayload = jwtManager.verifyAccessToken(tokens.accessToken);

      expect(decodedPayload.sub).toBe('user123');
    });

    it('should reject invalid tokens', () => {
      expect(() => {
        jwtManager.verifyAccessToken('invalid-token');
      }).toThrow(AuthenticationError);
    });

    it('should reject tokens with wrong signature', () => {
      const otherManager = new JwtManager({
        ...testConfig,
        secret: 'different-secret-key-min-32-characters',
      });

      const tokens = otherManager.generateTokens({ sub: 'user123' });

      expect(() => {
        jwtManager.verifyAccessToken(tokens.accessToken);
      }).toThrow(AuthenticationError);
    });
  });

  describe('refresh tokens', () => {
    it('should validate refresh tokens', () => {
      const tokens = jwtManager.generateTokens({ sub: 'user123' });
      const refreshPayload = jwtManager.verifyRefreshToken(tokens.refreshToken);

      expect(refreshPayload.sub).toBe('user123');
      expect(refreshPayload.type).toBe('refresh');
    });

    it('should refresh tokens with new payload', () => {
      const originalTokens = jwtManager.generateTokens({ 
        sub: 'user123',
        roles: ['user'] 
      });

      const newTokens = jwtManager.refreshTokens(originalTokens.refreshToken, {
        sub: 'user123',
        roles: ['user', 'admin'],
        permissions: ['user:read', 'admin:all'],
      });

      const newPayload = jwtManager.verifyAccessToken(newTokens.accessToken);
      expect(newPayload.roles).toContain('admin');
      expect(newPayload.permissions).toContain('admin:all');
    });
  });

  describe('configuration validation', () => {
    it('should reject short secrets', () => {
      expect(() => {
        new JwtManager({
          ...testConfig,
          secret: 'short',
        });
      }).toThrow(AuthenticationError);
    });

    it('should parse expiration times correctly', () => {
      const manager = new JwtManager({
        ...testConfig,
        expiresIn: '1h',
      });

      const tokens = manager.generateTokens({ sub: 'user123' });
      const payload = manager.verifyAccessToken(tokens.accessToken);
      
      // Should expire in approximately 1 hour
      const expectedExpiry = Math.floor(Date.now() / 1000) + 3600;
      expect(payload.exp).toBeCloseTo(expectedExpiry, -2); // Allow 100s tolerance
    });
  });
});
```

**Critérios de Aceitação:**
- [x] Testes completos para JWT generation e validation
- [x] Error cases testados
- [x] Configuration validation testada
- [x] Edge cases cobertos

---

### - [x] SUB-SEC-002-22: [15min] Implementar Testes para Auth Service

**Arquivos a criar:**
- `packages/security/__tests__/auth/service.test.ts`

**Implementação:**
```typescript
// __tests__/auth/service.test.ts
import { AuthService } from '../../src/auth/service';
import { createMockDatabaseRepositories } from '../../src/auth/database';
import { AuthenticationError } from '../../src/types/errors.types';

describe('AuthService', () => {
  let authService: AuthService;
  let mockRepositories: ReturnType<typeof createMockDatabaseRepositories>;

  const testConfig = {
    secret: 'test-secret-key-min-32-characters-long',
    expiresIn: '15m',
    refreshExpiresIn: '7d',
    algorithm: 'HS256' as const,
  };

  beforeEach(() => {
    mockRepositories = createMockDatabaseRepositories();
    authService = new AuthService(
      testConfig,
      mockRepositories.userRepo,
      mockRepositories.sessionRepo
    );
  });

  describe('login', () => {
    it('should login with valid credentials', async () => {
      const credentials = {
        email: 'admin@example.com',
        password: 'password123',
      };

      const result = await authService.login(credentials);

      expect(result.user.email).toBe(credentials.email);
      expect(result.tokens.accessToken).toBeDefined();
      expect(result.tokens.refreshToken).toBeDefined();
      expect(result.isFirstLogin).toBe(false);
    });

    it('should reject invalid email', async () => {
      const credentials = {
        email: 'nonexistent@example.com',
        password: 'password123',
      };

      await expect(authService.login(credentials))
        .rejects
        .toThrow(AuthenticationError);
    });

    it('should reject invalid password', async () => {
      const credentials = {
        email: 'admin@example.com',
        password: 'wrongpassword',
      };

      await expect(authService.login(credentials))
        .rejects
        .toThrow(AuthenticationError);
    });

    it('should track device info in login', async () => {
      const credentials = {
        email: 'admin@example.com',
        password: 'password123',
        deviceInfo: {
          userAgent: 'test-browser',
          ipAddress: '127.0.0.1',
        },
      };

      const result = await authService.login(credentials);
      
      // Device info should be stored in session
      expect(result.user.sessionId).toBeDefined();
    });
  });

  describe('token refresh', () => {
    it('should refresh tokens with valid refresh token', async () => {
      // First login
      const loginResult = await authService.login({
        email: 'admin@example.com',
        password: 'password123',
      });

      // Then refresh
      const refreshResult = await authService.refreshTokens({
        refreshToken: loginResult.tokens.refreshToken,
      });

      expect(refreshResult.tokens.accessToken).toBeDefined();
      expect(refreshResult.tokens.refreshToken).toBeDefined();
      expect(refreshResult.tokens.accessToken).not.toBe(loginResult.tokens.accessToken);
    });

    it('should reject invalid refresh token', async () => {
      await expect(authService.refreshTokens({
        refreshToken: 'invalid-token',
      })).rejects.toThrow(AuthenticationError);
    });

    it('should reject blacklisted refresh token', async () => {
      const loginResult = await authService.login({
        email: 'admin@example.com',
        password: 'password123',
      });

      // Logout to blacklist token
      await authService.logout(loginResult.user.id, {
        refreshToken: loginResult.tokens.refreshToken,
      });

      // Try to refresh with blacklisted token
      await expect(authService.refreshTokens({
        refreshToken: loginResult.tokens.refreshToken,
      })).rejects.toThrow(AuthenticationError);
    });
  });

  describe('logout', () => {
    it('should logout with refresh token', async () => {
      const loginResult = await authService.login({
        email: 'admin@example.com',
        password: 'password123',
      });

      await authService.logout(loginResult.user.id, {
        refreshToken: loginResult.tokens.refreshToken,
      });

      // Token should be blacklisted
      await expect(authService.refreshTokens({
        refreshToken: loginResult.tokens.refreshToken,
      })).rejects.toThrow(AuthenticationError);
    });

    it('should logout all devices', async () => {
      const userId = '1';
      
      await authService.logout(userId, {
        logoutAllDevices: true,
      });

      // All sessions for user should be revoked
      const sessions = await authService.getUserActiveSessions(userId);
      expect(sessions).toHaveLength(0);
    });
  });

  describe('token validation', () => {
    it('should validate valid access token', async () => {
      const loginResult = await authService.login({
        email: 'admin@example.com',
        password: 'password123',
      });

      const user = await authService.validateAccessToken(loginResult.tokens.accessToken);
      
      expect(user.id).toBe(loginResult.user.id);
      expect(user.email).toBe(loginResult.user.email);
    });

    it('should reject blacklisted access token', async () => {
      const loginResult = await authService.login({
        email: 'admin@example.com',
        password: 'password123',
      });

      // Blacklist the token manually
      await mockRepositories.sessionRepo.blacklistToken(
        loginResult.tokens.accessToken,
        new Date(Date.now() + 3600000)
      );

      await expect(authService.validateAccessToken(loginResult.tokens.accessToken))
        .rejects
        .toThrow(AuthenticationError);
    });
  });

  describe('registration', () => {
    it('should register new user', async () => {
      const registrationData = {
        email: 'newuser@example.com',
        password: 'newpassword123',
        confirmPassword: 'newpassword123',
      };

      const result = await authService.register(registrationData);

      expect(result.user.email).toBe(registrationData.email);
      expect(result.user.roles).toContain('user');
      expect(result.requiresVerification).toBe(false);
    });

    it('should reject duplicate email registration', async () => {
      const registrationData = {
        email: 'admin@example.com', // Already exists
        password: 'newpassword123',
        confirmPassword: 'newpassword123',
      };

      await expect(authService.register(registrationData))
        .rejects
        .toThrow(AuthenticationError);
    });

    it('should reject password mismatch', async () => {
      const registrationData = {
        email: 'newuser@example.com',
        password: 'password123',
        confirmPassword: 'differentpassword',
      };

      await expect(authService.register(registrationData))
        .rejects
        .toThrow(AuthenticationError);
    });
  });

  describe('password reset', () => {
    it('should initiate password reset', async () => {
      const result = await authService.initiatePasswordReset({
        email: 'admin@example.com',
      });

      expect(result).toBe(true);
    });

    it('should handle non-existent email gracefully', async () => {
      const result = await authService.initiatePasswordReset({
        email: 'nonexistent@example.com',
      });

      // Should still return true to prevent email enumeration
      expect(result).toBe(true);
    });
  });

  describe('maintenance', () => {
    it('should perform maintenance cleanup', async () => {
      const result = await authService.performMaintenance();

      expect(result.sessionsCleanedUp).toBeDefined();
      expect(result.resetTokensCleanedUp).toBeDefined();
      expect(typeof result.sessionsCleanedUp).toBe('number');
      expect(typeof result.resetTokensCleanedUp).toBe('number');
    });
  });
});
```

**Critérios de Aceitação:**
- [x] Testes completos para todos os métodos do AuthService
- [x] Mock repositories funcionando corretamente
- [x] Edge cases e error scenarios testados
- [x] Coverage de registration e password reset

---

### - [x] SUB-SEC-002-23: [15min] Implementar Testes de Integração

**Arquivos a criar:**
- `packages/security/__tests__/auth/integration.test.ts`

**Implementação:**
```typescript
// __tests__/auth/integration.test.ts
import { setupDevAuthentication } from '../../src/auth/setup';
import type { AuthSetup } from '../../src/auth/setup';

describe('Auth Integration Tests', () => {
  let authSetup: AuthSetup;

  beforeEach(() => {
    authSetup = setupDevAuthentication();
  });

  describe('complete auth flow', () => {
    it('should handle complete login -> refresh -> logout flow', async () => {
      // Step 1: Login
      const loginResult = await authSetup.authService.login({
        email: 'admin@example.com',
        password: 'password123',
      });

      expect(loginResult.user.email).toBe('admin@example.com');
      expect(loginResult.tokens.accessToken).toBeDefined();

      // Step 2: Validate access token
      const validatedUser = await authSetup.authService.validateAccessToken(
        loginResult.tokens.accessToken
      );

      expect(validatedUser.id).toBe(loginResult.user.id);

      // Step 3: Refresh tokens
      const refreshResult = await authSetup.authService.refreshTokens({
        refreshToken: loginResult.tokens.refreshToken,
      });

      expect(refreshResult.tokens.accessToken).not.toBe(loginResult.tokens.accessToken);

      // Step 4: Logout
      await authSetup.authService.logout(loginResult.user.id, {
        refreshToken: refreshResult.tokens.refreshToken,
      });

      // Step 5: Verify tokens are invalidated
      await expect(
        authSetup.authService.refreshTokens({
          refreshToken: refreshResult.tokens.refreshToken,
        })
      ).rejects.toThrow();
    });

    it('should handle registration -> login flow', async () => {
      // Step 1: Register new user
      const registrationResult = await authSetup.authService.register({
        email: 'testuser@example.com',
        password: 'testpassword123',
        confirmPassword: 'testpassword123',
      });

      expect(registrationResult.user.email).toBe('testuser@example.com');

      // Step 2: Login with new user
      const loginResult = await authSetup.authService.login({
        email: 'testuser@example.com',
        password: 'testpassword123',
      });

      expect(loginResult.user.email).toBe('testuser@example.com');
      expect(loginResult.tokens.accessToken).toBeDefined();
    });

    it('should handle password reset flow', async () => {
      // Step 1: Initiate password reset
      const resetInitiated = await authSetup.authService.initiatePasswordReset({
        email: 'admin@example.com',
      });

      expect(resetInitiated).toBe(true);

      // Note: In real implementation, we'd get the token from email
      // For testing, we need to access the token differently
      // This is simplified for the mock implementation
    });
  });

  describe('concurrent sessions', () => {
    it('should handle multiple concurrent sessions for same user', async () => {
      const email = 'admin@example.com';
      const password = 'password123';

      // Create multiple sessions
      const session1 = await authSetup.authService.login({
        email,
        password,
        deviceInfo: { userAgent: 'Browser1', ipAddress: '192.168.1.1' },
      });

      const session2 = await authSetup.authService.login({
        email,
        password,
        deviceInfo: { userAgent: 'Browser2', ipAddress: '192.168.1.2' },
      });

      expect(session1.tokens.accessToken).not.toBe(session2.tokens.accessToken);
      expect(session1.tokens.refreshToken).not.toBe(session2.tokens.refreshToken);

      // Both tokens should be valid
      const user1 = await authSetup.authService.validateAccessToken(session1.tokens.accessToken);
      const user2 = await authSetup.authService.validateAccessToken(session2.tokens.accessToken);

      expect(user1.id).toBe(user2.id);

      // Get active sessions
      const activeSessions = await authSetup.authService.getUserActiveSessions(user1.id);
      expect(activeSessions.length).toBeGreaterThanOrEqual(2);
    });

    it('should revoke all sessions when requested', async () => {
      const email = 'admin@example.com';
      const password = 'password123';

      // Create multiple sessions
      const session1 = await authSetup.authService.login({ email, password });
      const session2 = await authSetup.authService.login({ email, password });

      // Logout all devices
      await authSetup.authService.logout(session1.user.id, {
        logoutAllDevices: true,
      });

      // All tokens should be invalidated
      await expect(
        authSetup.authService.refreshTokens({
          refreshToken: session1.tokens.refreshToken,
        })
      ).rejects.toThrow();

      await expect(
        authSetup.authService.refreshTokens({
          refreshToken: session2.tokens.refreshToken,
        })
      ).rejects.toThrow();
    });
  });

  describe('security scenarios', () => {
    it('should prevent token reuse after logout', async () => {
      const loginResult = await authSetup.authService.login({
        email: 'admin@example.com',
        password: 'password123',
      });

      // Logout
      await authSetup.authService.logout(loginResult.user.id, {
        refreshToken: loginResult.tokens.refreshToken,
      });

      // Try to use access token after logout
      await expect(
        authSetup.authService.validateAccessToken(loginResult.tokens.accessToken)
      ).rejects.toThrow();
    });

    it('should handle session cleanup', async () => {
      // This test verifies that maintenance operations work
      const maintenanceResult = await authSetup.authService.performMaintenance();

      expect(maintenanceResult.sessionsCleanedUp).toBeGreaterThanOrEqual(0);
      expect(maintenanceResult.resetTokensCleanedUp).toBeGreaterThanOrEqual(0);
    });
  });

  describe('database abstraction', () => {
    it('should work with mock repositories', () => {
      expect(authSetup.repositories.userRepo).toBeDefined();
      expect(authSetup.repositories.sessionRepo).toBeDefined();
    });

    it('should handle user operations', async () => {
      const users = await authSetup.repositories.userRepo.listUsers?.();
      expect(Array.isArray(users)).toBe(true);
    });

    it('should handle session operations', async () => {
      const userId = '1';
      const refreshToken = 'test-token';
      
      const sessionId = await authSetup.repositories.sessionRepo.createSession(
        userId,
        refreshToken
      );

      expect(sessionId).toBeDefined();

      const session = await authSetup.repositories.sessionRepo.findSession(sessionId);
      expect(session?.userId).toBe(userId);
    });
  });
});
```

**Critérios de Aceitação:**
- [x] Testes de integração completos para fluxos end-to-end
- [x] Cenários de segurança testados
- [x] Multiple sessions e concurrent access testados
- [x] Database abstraction funcionando

---

### - [ ] SUB-SEC-002-24: [15min] Atualizar Documentação e README

**Arquivos a modificar:**
- `packages/security/README.md`

**Implementação:**
```typescript
// README.md (adicionar seção JWT Authentication)

## JWT Authentication

Complete JWT authentication system with refresh tokens, session management, and security features.

### Features

- **JWT Token Management**: Secure generation and validation of access/refresh tokens
- **Session Management**: Track user sessions across devices with metadata
- **User Registration**: Complete user registration with email verification support
- **Password Reset**: Secure password reset workflow with token expiration
- **Account Management**: Change password, manage sessions, security features
- **Database Abstraction**: Works with mock repositories or custom implementations
- **Security Features**: Token blacklisting, session cleanup, audit logging

### Quick Start

```typescript
import { setupDevAuthentication, createAuthRouter } from '@agenda-bella/security';

// Setup authentication with development defaults
const authSetup = setupDevAuthentication();

// Create Express router with all auth routes
const authRouter = createAuthRouter(authSetup);
app.use('/api/auth', authRouter);

// Use middleware in protected routes
app.get('/api/protected', authSetup.middleware.requireAuth, (req, res) => {
  res.json({ user: req.user });
});
```

### Configuration

```typescript
import { setupAuthentication } from '@agenda-bella/security';

const authSetup = setupAuthentication({
  jwt: {
    secret: process.env.JWT_SECRET!, // Min 32 characters
    expiresIn: '15m',
    refreshExpiresIn: '7d',
    algorithm: 'HS256',
  },
  database: {
    type: 'mock', // or 'custom' with your repositories
  },
  registration: {
    requireEmailVerification: true,
    defaultRoles: ['user'],
    allowedRoles: ['user', 'moderator'],
  },
  passwordReset: {
    tokenExpirationMinutes: 30,
    revokeSessionsOnReset: true,
  },
});
```

### API Endpoints

The `createAuthRouter` provides these endpoints:

**Core Authentication:**
- `POST /login` - User login with email/password
- `POST /refresh` - Refresh access token
- `POST /logout` - Logout user (requires auth)
- `GET /me` - Get current user info (requires auth)

**Registration:**
- `POST /register` - Register new user
- `POST /verify-email` - Verify email with token
- `POST /resend-verification` - Resend verification email

**Password Management:**
- `POST /password/reset` - Initiate password reset
- `POST /password/confirm` - Confirm password reset with token
- `GET /password/validate/:token` - Validate reset token
- `POST /password/change` - Change password (requires auth)

**Session Management:**
- `GET /sessions` - List active sessions (requires auth)
- `DELETE /sessions/:sessionId` - Revoke specific session (requires auth)

### Middleware Usage

```typescript
import { 
  requireAuth, 
  optionalAuth, 
  requireRole, 
  requirePermission 
} from '@agenda-bella/security';

// Require authentication
app.get('/protected', requireAuth(authService), handler);

// Optional authentication (sets req.user if token provided)
app.get('/public', optionalAuth(authService), handler);

// Require specific role
app.get('/admin', requireAuth(authService), requireRole('admin'), handler);

// Require specific permission
app.post('/users', requireAuth(authService), requirePermission('user:create'), handler);

// Custom authorization
app.get('/resource/:id', requireAuth(authService), requireOwnership((req) => {
  return getUserIdFromResource(req.params.id);
}), handler);
```

### Database Integration

The auth system uses repository abstractions that can be implemented for any database:

```typescript
import type { IUserRepository, ISessionRepository } from '@agenda-bella/security';

// Implement for your database (Prisma example)
class PrismaUserRepository implements IUserRepository {
  constructor(private prisma: PrismaClient) {}
  
  async findByEmail(email: string) {
    const user = await this.prisma.user.findUnique({ where: { email } });
    return user ? this.transformUser(user) : null;
  }
  
  // ... implement other methods
}

// Use custom repositories
const authSetup = setupAuthentication({
  jwt: { /* config */ },
  database: {
    type: 'custom',
    customRepositories: {
      userRepo: new PrismaUserRepository(prisma),
      sessionRepo: new PrismaSessionRepository(prisma),
    },
  },
});
```

### Security Features

- **Secure JWT**: Configurable algorithms, proper secret validation
- **Token Blacklisting**: Prevent token reuse after logout
- **Session Tracking**: Track device info, last access times
- **Rate Limiting Ready**: Integrates with rate limiting middleware
- **Audit Logging**: All auth events logged for security monitoring
- **LGPD Compliance**: User data handling with audit trails

### Testing

```bash
# Run auth tests
pnpm test auth

# Run with coverage
pnpm test:coverage auth

# Integration tests
pnpm test auth/integration
```

### Examples

**Basic Usage:**
```typescript
// Login
const result = await authService.login({
  email: 'user@example.com',
  password: 'password123',
});

// Use access token in requests
const user = await authService.validateAccessToken(result.tokens.accessToken);

// Refresh when token expires
const newTokens = await authService.refreshTokens({
  refreshToken: result.tokens.refreshToken,
});
```

**Advanced Session Management:**
```typescript
// Get user's active sessions
const sessions = await authService.getUserActiveSessions(userId);

// Revoke specific session
await authService.revokeUserSession(userId, sessionId);

// Logout all devices
await authService.logout(userId, { logoutAllDevices: true });
```

**Registration Flow:**
```typescript
// Register user
const result = await authService.register({
  email: 'newuser@example.com',
  password: 'securepassword123',
  confirmPassword: 'securepassword123',
});

if (result.requiresVerification) {
  // Send verification email (implementation specific)
  await sendVerificationEmail(result.user.email);
}
```

### Next Steps

This implementation provides the foundation for:
- **SEC-003**: ACL authorization system integration
- **SEC-004**: Rate limiting for auth endpoints
- **SEC-005**: Enhanced password security features

See [SEC-003.md](./SEC-003.md) for the next phase of security implementation.
```

**Critérios de Aceitação:**
- [ ] README atualizado com documentação completa
- [ ] Exemplos práticos e configuration guides
- [ ] API documentation clara
- [ ] Links para próximas implementações

**Comando de Validação Final:**
```bash
cd packages/security && pnpm build && pnpm test && pnpm type-check
```

---

## Resumo de Progresso

### Checklist de Conclusão da Task

- [ ] **Phase 1 Completa** (0/6): JWT Core Implementation ⏳
- [ ] **Phase 2 Completa** (0/6): Authentication Middleware ⏳
- [ ] **Phase 3 Completa** (0/8): Database Integration ⏳
- [ ] **Phase 4 Completa** (0/4): Testing e Documentação ⏳

### Critérios de Aceitação Gerais

- [ ] Todos os 24 subtasks concluídos
- [ ] Build sem erros: `pnpm build`
- [ ] Type checking passou: `pnpm type-check`
- [ ] Linting passou: `pnpm lint`
- [ ] Testes funcionando: `pnpm test`
- [ ] JWT authentication funcionando end-to-end
- [ ] Database abstraction preparada para CORE-001
- [ ] Integration com SEC-001 foundation testada
- [ ] Documentação e exemplos completos

### Próximas Tasks

Esta task estabelece o sistema de autenticação para:
- **SEC-003**: Sistema ACL com CASL (usa auth tokens para authorization)
- **SEC-004**: Rate Limiting (protege auth endpoints)
- **SEC-005**: Password Security (integra com password utilities)

### Comandos de Validação Final

```bash
# Validar toda a implementação
cd packages/security
pnpm install
pnpm build
pnpm type-check
pnpm lint
pnpm test

# Testar integração com monorepo
cd ../..
pnpm build --filter @agenda-bella/security
turbo test --filter @agenda-bella/security
```

---

**Tempo Total Estimado**: 6 horas (24 subtasks × 15min)  
**Data de Conclusão**: ___  
**Próxima Task**: SEC-003